
#include "slmHatches.hpp"
namespace Marc {
slmHatches::slmHatches(PrintObject* printObject, float infillDensity)
    : printObject(printObject), infillDensity(infillDensity) {
    // Initialize polygons from PrintObject
    //fillPolygons = printObject->getFillPolygons();  // Assuming a getter method exists in PrintObject
    //perimeterPolygons = printObject->getPerimeterPolygons();
}
float slmHatches::calculateHatchSpacing(float infillDensity) const {
    // Example calculation: 1mm hatch spacing for 100% density, increase spacing as density decreases
    return 1.0f / sqrtf(infillDensity);  // You may need a more complex formula based on your needs
}
void slmHatches::generateHatches() {
    // Generate hatches for the full fill and infill polygons
    generateInfillHatches();
    generatePerimeterHatches();
}
void slmHatches::generateInfillHatches() {
    // Calculate the hatch spacing based on infill density
    // float hatchSpacing = calculateHatchSpacing(infillDensity);

    // Iterate through fill polygons and generate hatch lines
   
}
void slmHatches::generatePerimeterHatches() {
    // For perimeter, we might use different hatch spacing or path strategies
    float hatchSpacing = calculateHatchSpacing(1.0f);  // Use full hatch density for the perimeter

   
}
std::vector<Polygon> slmHatches::generateHatchPathsForPolygon(const Polygon& polygon, float hatchSpacing) {
    std::vector<Polygon> hatchPaths;
    // Implement a hatch pattern generation strategy here:
    // E.g., generate parallel lines, zigzag, etc. inside the polygon.
    // For simplicity, let's assume we generate linear hatches (parallel lines).

    // Example of linear hatching
   
    return hatchPaths;
}



 
void slmHatches::fill_hatches() 
    {
       

        Slic3r::LayerPtrs layers = this->printObject->layers;

        // Iterate through each layer
        for (const auto& layer : layers) 
        {
          

            Slic3r::LayerRegionPtrs regions = layer->regions;

            // Iterate through each layer region
            for (const auto& layerm : regions) 
            {
               // std::cout << "extrusion paths to fill surfaces: " << layerm->fills.size() << std::endl;

            

                //std::cout << "extrusion paths to perimeters: " << layerm->perimeters.size() << std::endl;

              

                //std::cout << "extrusion paths to thin_fills: " << layerm->thin_fills.size() << std::endl;


                //std::cout << "surfaces generated by slicing Divided by type top/bottom/internal: " << layerm->slices.size() << std::endl;

                if (1) {
                    for (auto surface = layerm->slices.surfaces.begin(); surface != layerm->slices.surfaces.end(); ++surface) {
                        Slic3r::ExPolygon expp = surface->expolygon;
                        Slic3r::Polygon translated_path = expp.contour;
                        translated_path.translate(this->printObject->_copies_shift);
                        //sv->draw(translated_path, surface_color(&(*surface)), 1.0);

                        Polygons polys = expp.holes;
                        for (auto& poly : polys) {
                            //translated_path = poly;
                            poly.translate(this->printObject->_copies_shift);
                            //sv->draw(poly, surface_color(&(*surface)), 1.0);
                        }
                    }
                }

                //std::cout << "Collection of surfaces for infill generation: " << layerm->fill_surfaces.size() << std::endl;

                if (1) {
                    for (auto surface = layerm->fill_surfaces.surfaces.begin(); surface != layerm->fill_surfaces.surfaces.end(); ++surface) {
                        Slic3r::ExPolygon expp = surface->expolygon;
                        Slic3r::Polygon translated_path = expp.contour;
                        translated_path.translate(this->printObject->_copies_shift);
                        //sv->draw(translated_path, surface_color(&(*surface)), 1.0);

                        Polygons polys = expp.holes;
                        for (const auto& poly : polys) {
                            translated_path = poly;
                            translated_path.translate(this->printObject->_copies_shift);
                           // sv->draw(translated_path, surface_color(&(*surface)), 1.0);
                        }
                    }
                }

                //std::cout << "bridged Polygons: " << layerm->bridged.size() << std::endl;

                if (1) {
                    for (auto polygon = layerm->bridged.begin(); polygon != layerm->bridged.end(); ++polygon) {
                        Slic3r::Polyline translated_path = (*polygon);
                        translated_path.translate(this->printObject->_copies_shift);
                       // sv->draw(translated_path, "black", 1.0);
                    }
                }

               // std::cout << "Polyline unsupported_bridge_edges\n" << layerm->unsupported_bridge_edges.polylines.size() << std::endl;

                if (1) {
                    for (auto polyline = layerm->unsupported_bridge_edges.polylines.begin(); polyline != layerm->unsupported_bridge_edges.polylines.end(); ++polyline) {
                        Slic3r::Polyline translated_path = (*polyline);
                        translated_path.translate(this->printObject->_copies_shift);
                       // sv->draw(translated_path, "red", 1.0);
                    }
                }
            }

         
        }
    }



}